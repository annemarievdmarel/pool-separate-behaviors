---
title: "Pool vs separate displacements & crowds: GENERATE REFERENCE DATA"
author: "Liz Hobson"
date: "May 9, 2020"
output: html_document
---

#Load packages and helper code
```{r}
library(dplyr)
library(reshape2)
library(stringr)
```


#Import data & process
```{r}
# import observed data

# TO TEST/EXPLORE scripts/analyses:
EXPLORE_perpre_aggCD <- read.csv(file="EXPLORE-perpre-aggCD.csv") 
observed <- EXPLORE_perpre_aggCD %>%
  rename(rowID=X) # only necessary if the first column is an X

# FINAL ANALYSIS:
#ANALYZE_per0_aggCD <- read.csv(file="ANALYZE-per0-aggCD.csv") # final analyses
#agg.data <- subset(ANALYZE_per0_aggDC, days=="last") #this is the ANALYZE data for the actual analyses in the final paper
#observed <- agg.data

head(observed)
str(observed)
```


#Check
```{r}
unique(observed$actor)
unique(observed$subject)
unique(observed$date)

sum(observed$crowd)
sum(observed$displace)
sum(observed$total.DC)

```


# Summarize data: find total events per dyad (pool across days)
```{r}
observedXdyad <- observed
observedXdyad <- observedXdyad %>% 
                  dplyr::group_by(actor, subject) %>% 
                  dplyr::summarise(observed.crowd=sum(crowd),
                          observed.displace=sum(displace),
                          observed.totalCD=sum(total.DC)) 
observedXdyad <- as.data.frame(observedXdyad)   
observedXdyad$actor <- as.character(observedXdyad$actor)
observedXdyad$subject <- as.character(observedXdyad$subject)
```


## Produce reference model
Test real patterns with randomized reference model: Using this reference model, we test whether randomizing the number of interactions across two behavior types results in indistinguishable structural patterns in a reference model compared to the observed data.

Change: Randomly re-allocate aggression to number of displacements and number of crowds by dyad. 
Preserve: Keep total events (n disp + n crowd) by dyad the same

```{r}
head(observedXdyad) # name from summarize ref model

replicates <- 100
#observed.data <- aggdata.subd.sumXdyad 

run=2

#make empty dataframe to write loop results into
ref.model <- data.frame(actor=character(),
                       subject=character(),
                       observed.crowd=numeric(),
                       observed.displace=numeric(),
                       observed.totalCD=numeric(),
                       random.crowd=numeric(),
                       random.displace=numeric())


for (run in 1:replicates) {
  r.seed <- run
  set.seed(r.seed)
  ref.data <- aggdata.sumXdyad %<>%
                rowwise() %>%
                dplyr::mutate(random.displace = sample(0:observed.totalCD, 1),
                              random.crowd = observed.totalCD-random.displace)
  
  ref.data$runID <- rep(paste0("run",str_pad(r.seed, 3, side="left", pad = "0")),    length(aggdata.sumXdyad$actor)) #generates run IDs that are all 3 digits (001-100), change to 4 digit-padding if running >999
    
  ref.data <- as.data.frame(ref.data)
  ref.model <- rbind.data.frame(ref.model, ref.data)
}

```


## Check the reference model output
For example, runs should have different random.disp and random.crowd from observed data, runs should be different from each other, run should contain new divisions of displacement vs crowd events
```{r}
#check that the randomized interactions vary from the observed interactions
ref.model$random.displace == ref.model$observed.displace
ref.model$random.crowd == ref.model$observed.crowd

#check that runs are different from each other
head(subset(ref.model, runID=="run001"))
head(subset(ref.model, runID=="run002"))
head(subset(ref.model, runID=="run003"))
head(subset(ref.model, runID=="run011"))

#check that all runs ran as expected
unique(ref.model$runID)
length(unique(ref.model$runID))


######
        #loop to compare random to observed displacements for each runID
uniqrun = unique(ref.model$runID)
randvobs = data.frame(nmatches = numeric(), compar = character())
nrowxrun = nrow(aggdata.subd.sumXdyad)

for(i in uniqrun){
        nmatches = sum(ref.model[ref.model$runID==i,]$random.displace==ref.model[ref.model$runID==i,]$observed.displace)
        run = i
        df = as.data.frame(nmatches, run)
        randvobs=rbind.data.frame(randvobs,df)
        
        if(sum(randvobs[,1]==nrowxrun)>0){
                                break
                        } #if there is at least 1 occurrence of a complete match between random.displace and observed.displace columns, then break the loop. No more comparisons will be made. Look at end of randvobs to see which runs had a complete match
}


        #loop that compares random.crowds from each run to all other runs 
uniqrun = unique(ref.model$runID)
empdf = data.frame(nmatches = numeric(), compar = character())
nrowxrun = nrow(aggdata.subd.sumXdyad)

start.time = Sys.time()
        for (i in uniqrun) {
                
                #make uniqrunj (a list of all runIDs that come after i)
                n= which(!is.na(match(uniqrun,i))) 
                uniqrunj = uniqrun[n:length(uniqrun)] 
                uniqrunj = uniqrunj[uniqrunj!=i] 
                        
                for (j in uniqrunj) {
                  
                        nmatches = sum(ref.model[ref.model$runID==i,]$random.crowd==ref.model[ref.model$runID==j,]$random.crowd)    # gives the number of dyads for which the number of crowds in run i matches that in run j
                        
                        compar = paste(i,j, sep="-") #a vector to keep track of which runs are being compared
                        df = as.data.frame(nmatches,compar)
                        empdf=rbind.data.frame(empdf,df)
                  
                        if(sum(empdf[,1]==nrowxrun)>0){
                                break
                        } #if there is at least 1 occurrence of a complete match between random.crowd columns                         from the two runs, then break the inner loop
                        
                }
        
                val= as.numeric(substr(i,4,6))
                if(val %% 10==0) {
              cat(paste0("iteration: ", val, "\n"))
                   }# see loop progress at every 10 iterations
                               
                if(sum(empdf[,1]==nrowxrun)>0){
                        break
                } #if there is at least 1 occurrence of a complete match between random.crowd columns from                   the two runs, then break the entire loop - no more comparisons will be made. Look at end of                  empdf to see which runs had a complete match
                
        } #returns empdf with number of matches for each pair of runs being compared

end.time = Sys.time()

#Time to run:
end.time - start.time

#rm(i,j, df, n, uniqrunj, val)
#i="run050"
#j="run007"

######

```


## SAVE RUN OUTPUT FOR FINAL ANALYSIS
Check refmodel files to see whether set.seed works
```{r}
refmodeldata <- read.csv(file="EXPLORE-refmodeldata.csv") %>% select(-X)  # file from github
refmodel.vAM <- ref.model # file from local environment
setdiff(refmodeldata, refmodel.vAM) 

```

Files are the same so set.seed did work. 

** Note: change the file path to save to another location

```{r}
#WRITE DATA 
dfile.loc <- "C:/Users/Liz/Dropbox/A ACTIVE MSs/2020-05 Pool vs separate behaviors/poolVSseparate/"
#dfile.loc <- "C:/Users/avdma/OneDrive - University of Cincinnati/Documents/Postdoc_UC/Hobson lab/pool-separate-behaviors/"
#dfile.loc <- "YOUR LOCATION"

write.csv(ref.model, file = paste(dfile.loc, "EXPLORE-refmodeldata.csv", sep=""))	
```

