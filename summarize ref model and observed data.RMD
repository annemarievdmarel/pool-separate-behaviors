---
title: "Pool vs separate displacements & crowds: summarize"
author: "Liz Hobson"
date: "May 9, 2020"
output: html_document
---

#Load packages and helper code
```{r, include=FALSE}
library(dplyr)
library(reshape2)
library(stringr)
library(purrr)
library(EloRating)
library(domstruc) #install_github("danm0nster/domstruc")

```


#Import data & process
Load the data from the project either for the full observed dataset (first chunk) or the sampled dataset (second chunk)

OBSERVED data
```{r}
# EXPLORE observed data 
EXPLORE_perpre_aggCD <- read.csv(file="EXPLORE-perpre-aggCD.csv")
observed <- EXPLORE_perpre_aggCD
head(observed)

# ANALYZE observed data
#ANALYZE_per0_aggCD <- read.csv(file="ANALYZE-per0-aggCD.csv")
#observed <- ANALYZE_per0_aggCD
#head(observed)

observedXdyad <- observed # observed aggression by dyad
observedXdyad <- observedXdyad %>% 
                  dplyr::group_by(actor, subject) %>% 
                  dplyr::summarise(observed.crowd=sum(crowd),
                          observed.displace=sum(displace),
                          observed.totalCD=sum(total.DC)) 
observedXdyad <- as.data.frame(observedXdyad)   
observedXdyad$actor <- as.character(observedXdyad$actor)
observedXdyad$subject <- as.character(observedXdyad$subject)
str(observedXdyad)


#reference model data
EXPLORE_refmodeldata <- read.csv(file="EXPLORE-refmodeldata.csv")
head(EXPLORE_refmodeldata)
ref.model <- EXPLORE_refmodeldata #update name here when changing to ANALYZE ref model


#reference model correlations of crowd vs displacements
EXPLORE_refmodelCOR_CxD <- read.csv(file="EXPLORE_refmodelCOR_CxD.csv") %>% select(-X) #head(EXPLORE_refmodelCOR_CxD)
COR.refmodel <- EXPLORE_refmodelCOR_CxD
```

SAMPLED sparse data
```{r}
# EXPLORE SAMPLED data 
EXPLORE_sparse_aggCD <- read.csv(file="EXPLORE-sparse-aggCD.csv") 
observed <- EXPLORE_sparse_aggCD %>%
  dplyr::rename(rowID=X)

# ANALYZE observed data
#ANALYZE_per0_aggCD <- read.csv(file="ANALYZE-per0-aggCD.csv")
#observed <- ANALYZE_per0_aggCD
#head(observed)

observedXdyad <- observed # observed aggression by dyad
observedXdyad <- observedXdyad %>% 
                  dplyr::group_by(runID,actor, subject) %>% 
                  dplyr::summarise(observed.crowd=sum(crowd),
                          observed.displace=sum(displace),
                          observed.totalCD=sum(total.DC)) 
observedXdyad <- as.data.frame(observedXdyad)   
observedXdyad$actor <- as.character(observedXdyad$actor)
observedXdyad$subject <- as.character(observedXdyad$subject)
str(observedXdyad)


#reference model correlations of crowd vs displacements
EXPLORE.sample.COR.refmodel<-read.csv(file = "EXPLORE_sample_refmodelCOR.csv") %>% select(-X)
#head(EXPLORE.sample.COR.refmodel)
COR.refmodel <- EXPLORE.sample.COR.refmodel
```





## Helper functions & data
```{r}

#make matrix function (from dataframe, 1st col with row names)
matrix.please<-function(x) {
  m<-as.matrix(x[,-1])
  rownames(m)<-x[,1]
  m
}

#list of all valid color combinations/bird IDs
bird.list <- c("BBB","BBG","BBR","BGB","BGG","BRB","BRR","GBB","GBG","GGB","GGG","GGR","GRG","GRR","RBB","RBG","RBR","RGG","RGR","RRG","RRR")
length(bird.list)

## dataframe of all possible dyad combinations
dyad.list <- expand.grid(bird.list, bird.list) #head(dyad.list)
names(dyad.list) <- c("actor", "subject")
dyad.list <- subset(dyad.list, actor!=subject)
dyad.list$dyadID <- paste(dyad.list$actor, dyad.list$subject, sep="-")
dyad.list$actor <- as.character(dyad.list$actor)
dyad.list$subject <- as.character(dyad.list$subject)
head(dyad.list)

```


# Check observed data
Need to make sure that all birds in the group are included in each network (fill no interactions with zeros)

```{r}
# list of all dyads
head(dyad.list)
str(dyad.list)

# observed aggression by dyad by behavior
head(observedXdyad)
str(observedXdyad)

#subset(observedXdyad, actor==subject) #check that we don't have any self-loops

# merge data with full dyad list in case any didn't interact
observedXdyad.alldyads <- merge(observedXdyad, dyad.list, 
                           by=c("actor", "subject"), 
                           all.y=TRUE)
head(observedXdyad.alldyads)
str(observedXdyad.alldyads) #should have 420 dyads #length(dyad.list$dyadID)

# convert NA to 0's
observedXdyad.alldyads[is.na(observedXdyad.alldyads)] <- 0

#check
head(observedXdyad.alldyads)
length(observedXdyad.alldyads$dyadID) # with 21 birds, we should have 420 dyads total


# cast into square matrix with actor vertically in first column, all subjects horizontally in first row
OBS.crd.mx <- dcast(observedXdyad.alldyads, actor~subject, value.var="observed.crowd")

# check that actors and subjects are correct
subset(observedXdyad.alldyads, actor=="BBB" & subject=="GGG")
subset(observedXdyad.alldyads, actor=="GGG" & subject=="BBB")
OBS.crd.mx[1,] #BBB wins against GGG
OBS.crd.mx[11,] # GGG wins against BBB
```


##########
# Summarize OBSERVED DATA

```{r}
start.time <- Sys.time()

obs.cor <- cor(observedXdyad.alldyads$observed.crowd, observedXdyad.alldyads$observed.displace)

  #summarize basic info
  n.Obcrowd <- sum(observedXdyad.alldyads$observed.crowd)
  n.Obdisplace <- sum(observedXdyad.alldyads$observed.displace)
  n.totalCD <- sum(observedXdyad.alldyads$observed.displace+ observedXdyad.alldyads$observed.crowd)
  
  prop.Obdisplace <- n.Obdisplace/(n.Obdisplace+n.Obcrowd)
  prop.Obcrowd <- n.Obcrowd/(n.Obdisplace+n.Obcrowd)

  obsdyads.crowd <- subset(observedXdyad.alldyads, observed.crowd>0)
  obsdyads.displace <- subset(observedXdyad.alldyads, observed.displace>0)

  n.Obcrowd.dyads <- length(obsdyads.crowd$actor)
  n.Obdisplace.dyads <- length(obsdyads.displace$actor)

  Obcrowd.density <- n.Obcrowd.dyads/length(dyad.list$dyadID)
  Obdisplace.density <- n.Obdisplace.dyads/length(dyad.list$dyadID)
  ObtotalCD.density <- (n.Obcrowd.dyads + n.Obdisplace.dyads)/length(dyad.list$dyadID)
  
  # Pool basic summaries
  Obcd.basic <- cbind.data.frame(obs.cor, 
                                n.Obcrowd, n.Obdisplace,
                                prop.Obcrowd, prop.Obdisplace, 
                                n.Obcrowd.dyads, n.Obdisplace.dyads,
                                Obcrowd.density, Obdisplace.density, 
                                n.totalCD,ObtotalCD.density
                                )
  
  # START NETWORK ANALYSES
  
  ###### separate analyses by type (crowd vs displace)
  
  ### CROWD
  obs.crowd.mx <- reshape2::dcast(observedXdyad.alldyads, actor~subject, value.var="observed.crowd") #head(ref.crowd.mx)
  obs.crowd.mx[is.na(obs.crowd.mx)] <- 0
  obs.crowd.mx <- matrix.please(obs.crowd.mx)
  
  #Find linearity
  Oblin.crowd<- EloRating::h.index(obs.crowd.mx, loops = 1000)
  Obcrowd.linearity <- Oblin.crowd[3,2]

  #Find steepness
  Obcrowd.steepness <- steepness::getStp(obs.crowd.mx, method="Dij")
  
  #Find proportion unknown relationships, a measure of sparseness
  Obcrowd.prunk <- EloRating::prunk(obs.crowd.mx)
  Obcrowd.prunk.pu <- as.numeric(Obcrowd.prunk[1])
  Obcrowd.prunk.dyads <- as.numeric(Obcrowd.prunk[2]) # number of dyads with no interactions? double check because it didn't coincide with actual numbers -> seems like it is total N
  
  #Triangle transitivity
  Obcrowd.transi <- EloRating::transitivity(obs.crowd.mx, runs = 1000)
  Obcrowd.transi.Pt <- Obcrowd.transi[1]  # proportion of transitive triads
  Obcrowd.transi.ttri <- Obcrowd.transi[2]  # triangle transitivity
  
  # Compute focus & position
  Obcrowd.focus <- dom_focus(obs.crowd.mx)
  Obcrowd.position <- dom_position(obs.crowd.mx)
  Obcrowd.fp <- cbind.data.frame(Obcrowd.focus, Obcrowd.position)
  colnames(Obcrowd.fp) <- c("focus", "position")
  
  #Compute blur models
  Obcrowd.blur <- dom_make_blur_data(obs.crowd.mx)
  
  #Find strategy
  strategy.Obcrowd <- dom_categorize_strategy(data=Obcrowd.fp, blur_data=Obcrowd.blur)
  
  
  ### POOL crowd hierarchy
  Obcrowd.hier <- cbind.data.frame(
                                  Obcrowd.linearity, 
                                  Obcrowd.steepness, 
                                  Obcrowd.prunk.pu, Obcrowd.prunk.dyads,
                                  Obcrowd.transi.Pt, Obcrowd.transi.ttri,
                                  Obcrowd.focus, Obcrowd.position,
                                  strategy.Obcrowd
                                  )
  
  ### DISPLACEMENT
  
  obs.disp.mx <- reshape2::dcast(observedXdyad.alldyads, actor~subject, value.var="observed.displace") #head(ref.disp.mx)
  obs.disp.mx[is.na(obs.disp.mx)] <- 0
  obs.disp.mx <- matrix.please(obs.disp.mx)
  
  #Find linearity
  Oblin.disp<- EloRating::h.index(obs.disp.mx, loops = 1000)
  Obdisp.linearity <- Oblin.disp[3,2]

  #Find steepness
  Obdisp.steepness <- steepness::getStp(obs.disp.mx, method="Dij")
  
  #Find proportion unknown relationships, a measure of sparseness
  Obdisp.prunk <- EloRating::prunk(obs.disp.mx)
  Obdisp.prunk.pu <- as.numeric(Obdisp.prunk[1])
  Obdisp.prunk.dyads <- as.numeric(Obdisp.prunk[2])
  
  #Triangle transitivity
  Obdisp.transi <- EloRating::transitivity(obs.disp.mx, runs = 1000)
  Obdisp.transi.Pt <- Obdisp.transi[1]  
  Obdisp.transi.ttri <- Obdisp.transi[2]  
  
  # Compute focus & position
  Obdisp.focus <- dom_focus(obs.disp.mx)
  Obdisp.position <- dom_position(obs.disp.mx)
  Obdisp.fp <- cbind.data.frame(Obdisp.focus, Obdisp.position)
  colnames(Obdisp.fp) <- c("focus", "position")
  
  #Compute blur models
  Obdisp.blur <- dom_make_blur_data(obs.disp.mx)
  
  #Find strategy
  strategy.Obdisp <- dom_categorize_strategy(data=Obdisp.fp, blur_data=Obdisp.blur)
  
  
  ### POOL disp hierarchy
  Obdisp.hier <- cbind.data.frame(
                                  Obdisp.linearity, 
                                  Obdisp.steepness, 
                                  Obdisp.prunk.pu, Obdisp.prunk.dyads,
                                  Obdisp.transi.Pt, Obdisp.transi.ttri,
                                  Obdisp.focus, Obdisp.position,
                                  strategy.Obdisp
                                  )

  
  
  ### TOTAL (totalCD, all crowds + all displaces)
  
  obs.totalCD.mx <- reshape2::dcast(observedXdyad.alldyads, actor~subject, value.var="observed.totalCD") #head(ref.totalCD.mx)
  obs.totalCD.mx[is.na(obs.totalCD.mx)] <- 0
  obs.totalCD.mx <- matrix.please(obs.totalCD.mx)
  
  #Find linearity
  Oblin.totalCD<- EloRating::h.index(obs.totalCD.mx, loops = 1000)
  ObtotalCD.linearity <- Oblin.totalCD[3,2]

  #Find steepness
  ObtotalCD.steepness <- steepness::getStp(obs.totalCD.mx, method="Dij")
  
  #Find proportion unknown relationships, a measure of sparseness
  ObtotalCD.prunk <- EloRating::prunk(obs.totalCD.mx)
  ObtotalCD.prunk.pu <- as.numeric(ObtotalCD.prunk[1])
  ObtotalCD.prunk.dyads <- as.numeric(ObtotalCD.prunk[2])
  
  #Triangle transitivity
  ObtotalCD.transi <- EloRating::transitivity(obs.totalCD.mx, runs = 1000)
  ObtotalCD.transi.Pt <- ObtotalCD.transi[1]  # proportion of transitive triads
  ObtotalCD.transi.ttri <- ObtotalCD.transi[2]  # triangle transitivity
  
  # Compute focus & position
  ObtotalCD.focus <- dom_focus(obs.totalCD.mx)
  ObtotalCD.position <- dom_position(obs.totalCD.mx)
  ObtotalCD.fp <- cbind.data.frame(ObtotalCD.focus, ObtotalCD.position)
  colnames(ObtotalCD.fp) <- c("focus", "position")
  
  #Compute blur models
  ObtotalCD.blur <- dom_make_blur_data(obs.totalCD.mx)
  
  #Find strategy
  Obstrategy.totalCD <- dom_categorize_strategy(data=ObtotalCD.fp, blur_data=ObtotalCD.blur)
  
  
  ### POOL totalCD hierarchy
  ObtotalCD.hier <- cbind.data.frame(
                                  ObtotalCD.linearity, 
                                  ObtotalCD.steepness, 
                                  ObtotalCD.prunk.pu, ObtotalCD.prunk.dyads,
                                  ObtotalCD.transi.Pt, ObtotalCD.transi.ttri,
                                  ObtotalCD.focus, ObtotalCD.position,
                                  Obstrategy.totalCD
                                  )
    
# POOL ALL DATA
observed.summary <- cbind.data.frame(Obcd.basic, Obcrowd.hier, Obdisp.hier, ObtotalCD.hier)

# Check time
end.time <- Sys.time()

#Time to run:
end.time - start.time


#check the data
t(observed.summary)

```

## Export data
OBSERVED 
```{r}
write.csv(observed.summary, file = "EXPLORE-SUMM.observed.csv")
```


SAMPLED 
```{r}
write.csv(observed.summary, file = "EXPLORE-SUMM.sampled.csv")
```




############
# Loop to produce all reference model summaries (except strategies)
Strategies take about 12 min each to run (12x100 crowd, 12x100 disp = 40 hours!)
Loop other than strategies takes about 14 min for full dataset and 4 min for sampled dataset. 

```{r}
#run.s #list of all run names
#head(ref.model)
#head(EXPLORE_refmodelCOR_CxD)

run.s <- as.character(unique(ref.model$runID))
n.total.dyads <- length(dyad.list$dyadID) #total number of dyads 
replicates <- 100 #how many runs of the reference model were done

#make empty dataframe to fill
ref.model.summaries <- data.frame(run.code=character(), 
                                  run.cor=numeric(), 
                                  n.Rcrowd=numeric(), 
                                  n.Rdisplace=numeric(),
                                  prop.Rcrowd=numeric(), 
                                  prop.Rdisplace=numeric(), 
                                  n.Rcrowd.dyads=numeric(), 
                                  n.Rdisplace.dyads=numeric(),
                                  Rcrowd.density=numeric(), 
                                  Rdisplace.density=numeric(),
                                  Rcrowd.linearity=numeric(), 
                                  Rcrowd.steepness=numeric(), 
                                  Rcrowd.prunk.pu=numeric(), 
                                  Rcrowd.prunk.dyads=numeric(),
                                  Rcrowd.transi.Pt=numeric(), 
                                  Rcrowd.transi.ttri=numeric(),
                                  Rdisp.linearity=numeric(), 
                                  Rdisp.steepness=numeric(), 
                                  Rdisp.prunk.pu=numeric(), 
                                  Rdisp.prunk.dyads=numeric(),
                                  Rdisp.transi.Pt=numeric(), 
                                  Rdisp.transi.ttri=numeric()
                                  )
#run=2

#n.Ocrowd <- sum(run.data$observed.crowd)
#n.Odisplace <- sum(run.data$observed.displace)
start.time <- Sys.time()

for(run in 1:replicates){
  run.code <- run.s[run]
  print(run.code)
  run.data <- subset(ref.model, runID==run.code)
  run.corr <- subset(COR.refmodel, runID==run.code)
  run.cor <- run.corr[1,2]
  
  #summarize basic info
  n.Rcrowd <- sum(run.data$random.crowd)
  n.Rdisplace <- sum(run.data$random.displace)
  prop.Rdisplace <- n.Rdisplace/(n.Rdisplace+n.Rcrowd)
  prop.Rcrowd <- n.Rcrowd/(n.Rdisplace+n.Rcrowd)

  dyads.crowd <- subset(run.data, random.crowd>0)
  dyads.displace <- subset(run.data, random.displace>0)

  n.Rcrowd.dyads <- length(dyads.crowd$actor)
  n.Rdisplace.dyads <- length(dyads.displace$actor)

  Rcrowd.density <- n.Rcrowd.dyads/n.total.dyads
  Rdisplace.density <- n.Rdisplace.dyads/n.total.dyads
  
  # Pool basic summaries
  Rcd.basic <- cbind.data.frame(run.code, run.cor, 
                                n.Rcrowd, n.Rdisplace,
                                prop.Rcrowd, prop.Rdisplace, 
                                n.Rcrowd.dyads, n.Rdisplace.dyads,
                                Rcrowd.density, Rdisplace.density
                                )
  #str(Rcd.basic)
  
  # START NETWORK ANALYSES
  ref.modelW0s <- merge(dyad.list, run.data, all.x=TRUE,
                       by=c("actor", "subject")) #head(run.dataW0s)
  
  #print a check
  check <- length(ref.modelW0s$actor)
  print(check)
  
  #make runID character (not factor)
  ref.modelW0s$runID <- as.character(ref.modelW0s$runID)
 
   #fill newly-merged data with 0's where no interactions
  ref.modelW0s[is.na(ref.modelW0s)] <- 0
  
###### separate analyses by type (crowd vs displace)
  
  ### CROWD
  
  ref.crowd.mx <- reshape2::dcast(ref.modelW0s, actor~subject, value.var="random.crowd") #head(ref.crowd.mx)
  ref.crowd.mx[is.na(ref.crowd.mx)] <- 0 #for linearity measure, matrix needs to be fully filled, no NAs
  ref.crowd.mx <- matrix.please(ref.crowd.mx)
  
  #Find linearity
  lin.crowd<- EloRating::h.index(ref.crowd.mx, loops = 1000)
  Rcrowd.linearity <- lin.crowd[3,2]

  #Find steepness
  Rcrowd.steepness <- steepness::getStp(ref.crowd.mx, method="Dij")
  
  #Find proportion unknown relationships, a measure of sparseness
  Rcrowd.prunk <- EloRating::prunk(ref.crowd.mx)
  Rcrowd.prunk.pu <- as.numeric(Rcrowd.prunk[1])
  Rcrowd.prunk.dyads <- as.numeric(Rcrowd.prunk[2])
  
  #Triangle transitivity
  Rcrowd.transi <- EloRating::transitivity(ref.crowd.mx, runs = 1000)
  Rcrowd.transi.Pt <- Rcrowd.transi[1]  # proportion of transitive triads
  Rcrowd.transi.ttri <- Rcrowd.transi[2]  # triangle transitivity
  
  
  ### POOL crowd hierarchy
  Rcrowd.hier <- cbind.data.frame(
                                  Rcrowd.linearity, 
                                  Rcrowd.steepness, 
                                  Rcrowd.prunk.pu, Rcrowd.prunk.dyads,
                                  Rcrowd.transi.Pt, Rcrowd.transi.ttri
                                  )
  
  ### DISPLACEMENT
  
  ref.disp.mx <- reshape2::dcast(ref.modelW0s, actor~subject, value.var="random.displace") #head(ref.disp.mx)
  ref.disp.mx[is.na(ref.disp.mx)] <- 0
  ref.disp.mx <- matrix.please(ref.disp.mx)
  
  #Find linearity
  lin.disp<- EloRating::h.index(ref.disp.mx, loops = 1000)
  Rdisp.linearity <- lin.disp[3,2]

  #Find steepness
  Rdisp.steepness <- steepness::getStp(ref.disp.mx, method="Dij")
  
  #Find proportion unknown relationships, a measure of sparseness
  Rdisp.prunk <- EloRating::prunk(ref.disp.mx)
  Rdisp.prunk.pu <- as.numeric(Rdisp.prunk[1])
  Rdisp.prunk.dyads <- as.numeric(Rdisp.prunk[2])
  
  #Triangle transitivity
  Rdisp.transi <- EloRating::transitivity(ref.disp.mx, runs = 1000)
  Rdisp.transi.Pt <- Rdisp.transi[1]  # proportion of transitive triads
  Rdisp.transi.ttri <- Rdisp.transi[2]  # triangle transitivity
  

  
  #### POOL displace hierarchy
  Rdisp.hier <- cbind.data.frame(
                                  Rdisp.linearity, 
                                  Rdisp.steepness, 
                                  Rdisp.prunk.pu, Rdisp.prunk.dyads,
                                  Rdisp.transi.Pt, Rdisp.transi.ttri
                                  )
  
  # POOL ALL DATA
  run.sums <- cbind.data.frame(Rcd.basic, Rcrowd.hier, Rdisp.hier)
  ref.model.summaries <- rbind(ref.model.summaries, run.sums)
}

end.time <- Sys.time()

#Time to run:
end.time - start.time

#t(ref.model.summaries)
head(ref.model.summaries)

```


# Export data

OBSERVED
```{r}
write.csv(ref.model.summaries, "EXPLORE-SUMM.refmodel.csv")
```

SAMPLED
```{r}
write.csv(ref.model.summaries, "EXPLORE-SUMM.sampled.refmodel.csv")
```

